package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"
)

// pbPkgPathRoot 导出Pb文件库的根路径.
const pbPkgPathRoot = "github.com/godyy/ggs/internal/proto/pb/"

// pbCommonPath 导出common Pb的路径.
const pbCommonPath = "common"

// tagFromCommon 标识协议消息结构来自 common 的标签.
const tagFromCommon = "/from_common"

type enumItem struct {
	Name       string
	FromCommon bool
}

// parsePIDEnum parses a proto file and extracts enum entries for enum PID,
// including whether each entry's inline comment contains the tag /from_common.
func parsePIDEnum(protoPath string) ([]enumItem, error) {
	data, err := os.ReadFile(protoPath)
	if err != nil {
		return nil, fmt.Errorf("read proto %s: %w", protoPath, err)
	}

	src := string(data)
	// locate "enum PID" and the block braces
	start := strings.Index(src, "enum PID")
	if start < 0 {
		return nil, fmt.Errorf("enum PID not found in %s", protoPath)
	}
	// find opening brace
	open := strings.Index(src[start:], "{")
	if open < 0 {
		return nil, fmt.Errorf("opening brace for enum PID not found in %s", protoPath)
	}
	open += start
	// find closing brace after opening
	close := strings.Index(src[open+1:], "}")
	if close < 0 {
		return nil, fmt.Errorf("closing brace for enum PID not found in %s", protoPath)
	}
	close += open + 1

	block := src[open+1 : close]
	lines := strings.Split(block, "\n")
	items := make([]enumItem, 0, len(lines))
	// regex to match enum entries like: Name = 2; and capture optional inline comment
	re := regexp.MustCompile(`^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*([0-9]+)\s*;\s*(?://\s*(.*))?$`)

	for _, line := range lines {
		m := re.FindStringSubmatch(line)
		if len(m) == 4 {
			name := strings.TrimSpace(m[1])
			comment := strings.TrimSpace(m[3])
			if !strings.HasPrefix(name, "P") {
				return nil, fmt.Errorf("enum PID item %s must start with 'P'", name)
			}
			items = append(items, enumItem{
				Name:       name,
				FromCommon: comment != "" && strings.Contains(comment, tagFromCommon),
			})
		}
	}
	return items, nil
}

func generateRegisterFile(pkgPath string, registryVar string, items []enumItem) ([]byte, error) {
	var buf bytes.Buffer
	// Add do-not-edit banner
	buf.WriteString("// Code generated by proto/tools/gen_register; DO NOT EDIT.\n")
	buf.WriteString("// 该文件由工具生成，请勿手动编辑。\n\n")
	buf.WriteString("package types\n\n")
	// imports: always include pid package; include common if any item is FromCommon
	needCommon := false
	for _, it := range items {
		if it.FromCommon {
			needCommon = true
			break
		}
	}
	// compose full import path from root + relative pkgPath
	pkgImport := path.Join(pbPkgPathRoot, pkgPath)
	// derive package name prefix from basename of pkgPath
	pkgName := path.Base(pkgPath)
	if needCommon {
		buf.WriteString("import (\n")
		buf.WriteString(fmt.Sprintf("\t\"%s\"\n", pkgImport))
		buf.WriteString(fmt.Sprintf("\t\"%s\"\n", path.Join(pbPkgPathRoot, pbCommonPath)))
		buf.WriteString(")\n\n")
	} else {
		buf.WriteString(fmt.Sprintf("import \"%s\"\n\n", pkgImport))
	}
	buf.WriteString("func init() {\n")
	for _, it := range items {
		name := it.Name
		if strings.EqualFold(name, "PUnknown") { // skip Unknown
			continue
		}
		msg := strings.TrimPrefix(name, "P")
		msgPkg := pkgName
		if it.FromCommon {
			msgPkg = "common"
		}
		// e.g. C2S.register(c2s.PID_PLoginReq, &c2s.LoginReq{}) or &common.Error{}
		buf.WriteString(fmt.Sprintf("\t%s.register(%s.PID_%s, &%s.%s{})\n", registryVar, pkgName, name, msgPkg, msg))
	}
	buf.WriteString("}\n")

	// format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// return unformatted to help diagnose formatting errors
		return buf.Bytes(), fmt.Errorf("format generated code: %w", err)
	}
	return formatted, nil
}

func main() {
	// Require proto root via flag (no fallback to exePath)
	protoRoot := flag.String("proto-path", "", "path to proto root directory (e.g., /Users/you/work/ggs/internal/core/proto)")
	flag.Parse()
	if *protoRoot == "" {
		panic(fmt.Errorf("missing -proto-path flag: set path to ggs/internal/core/proto"))
	}

	typesDir := filepath.Join(*protoRoot, "types")
	protoDir := filepath.Join(*protoRoot, "protos")
	c2sProto := filepath.Join(protoDir, "c2s", "pid.proto")
	s2sProto := filepath.Join(protoDir, "s2s", "pid.proto")

	// Parse enums
	c2sItems, err := parsePIDEnum(c2sProto)
	if err != nil {
		panic(err)
	}
	s2sItems, err := parsePIDEnum(s2sProto)
	if err != nil {
		panic(err)
	}

	// Generate files
	c2sCode, err := generateRegisterFile(
		"c2s",
		"C2S",
		c2sItems,
	)
	if err != nil {
		panic(err)
	}
	s2sCode, err := generateRegisterFile(
		"s2s",
		"S2S",
		s2sItems,
	)
	if err != nil {
		panic(err)
	}

	// Write outputs
	if err := os.WriteFile(filepath.Join(typesDir, "c2s_register.go"), c2sCode, 0o644); err != nil {
		panic(err)
	}
	if err := os.WriteFile(filepath.Join(typesDir, "s2s_register.go"), s2sCode, 0o644); err != nil {
		panic(err)
	}
}
